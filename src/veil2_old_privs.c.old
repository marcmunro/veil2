/**
 * @file   veil2_old_privs.c
 * \code
 *     Author:       Marc Munro
 *     Copyright (c) 2020 Marc Munro
 *     License:      GPL V3
 * 
 * \endcode
 * @brief  
 * Old Veil privilege testing functions.  These use SPI calls to
 * directly interogate the veil2_session_privileges table.  These have
 * been replaced by much faster tests against memory-resident sdata
 * structures.  This file exists to preserve the old versions for
 * posterity for future developers who may need to do something similar.
 * 
 */




/** 
 * <code>veil2.i_have_global_priv(priv) returns bool</code> 
 *
 * Predicate to determine whether the current session user has a given
 * privilege, <code>priv</code>, with global scope.
 *
 * @param int privilege_id of privilege to test for
 *
 * @return boolean true if the session has the given privilege
 */
Datum
veil2_i_have_global_priv(PG_FUNCTION_ARGS)
{
    static void *saved_plan = NULL;
    bool result;
    bool found;
    bool pushed;
    Oid argtypes[] = {INT4OID};
    Datum args[] = {Int32GetDatum(priv)};
    int priv = PG_GETARG_INT32(0);
	
    if (session_ready) {
	veil2_spi_connect(&pushed,
			  "SPI connect failed in veil2_i_have_global_priv()");
	found = veil2_bool_from_query(
	    "select coalesce("
	    " (select privs ? $1"
	    "    from veil2_session_privileges v"
	    "   where v.scope_type_id = 1), false)",
	    1, argtypes, args,
	    &saved_plan, &result);

	veil2_spi_finish(pushed,
			 "SPI finish failed in veil2_i_have_global_priv()");
	result_counts[found && result]++;
	return found && result;
    }
    if (error_if_no_session()) {
	ereport(ERROR,
		(errcode(ERRCODE_INTERNAL_ERROR),
		 errmsg("Attempt to check privileges before call to "
			"veil2_reset_session.")));
    }
    else {
	result_counts[false]++;
    }
    return false;
}

/** 
 * <code>veil2.i_have_personal_priv(priv) returns bool</code> 
 *
 * Predicate to determine whether the current session user has a given
 * privilege, <code>priv</code>, in their personal scope (ie for data
 * pertaining to themselves).
 *
 * @param int privilege_id of privilege to test for
 * @param int accessor_id of the record being checked.
 *
 * @return boolean true if the session has the given privilege in the
 * personal scope of the given accessor_id
 */
Datum
veil2_i_have_personal_priv(PG_FUNCTION_ARGS)
{
	static void *saved_plan = NULL;
	bool result;
	bool found;
	bool pushed;
	int priv = PG_GETARG_INT32(0);
	int accessor_id = PG_GETARG_INT32(1);
	Oid argtypes[] = {INT4OID, INT4OID};
	Datum args[] = {Int32GetDatum(priv), Int32GetDatum(accessor_id)};
	
	if (session_ready) {
		veil2_spi_connect(&pushed,
						  "SPI connect failed in veil2_i_have_personal_priv()");
		found = veil2_bool_from_query(
			"select coalesce("
			" (select privs ? $1"
			"    from veil2_session_privileges v"
			"   where v.scope_type_id = 2"
			"     and v.scope_id = $2), false)",
			2, argtypes, args,
			&saved_plan, &result);

		veil2_spi_finish(pushed,
						 "SPI finish failed in veil2_i_have_personal_priv()");
		result_counts[found && result]++;
		return found && result;
	}
	if (error_if_no_session()) {
		ereport(ERROR,
				(errcode(ERRCODE_INTERNAL_ERROR),
				 errmsg("Attempt to check privileges before call to  "
						"veil2_reset_session.")));
	}
	else {
		result_counts[false]++;
	}
	return false;
}


/** 
 * <code>veil2.i_have_priv_in_scope(priv, scope_type_id, scope_id) 
 *     returns bool</code> 
 *
 * Predicate to determine whether the current session user has a given
 * privilege, <code>priv</code>, in a specific scope
 * (<code>scope_type_id</code>, <code>scope_id</code>).
 *
 * @param int privilege_id of privilege to test for
 * @param int scope_type_id of the record being checked.
 * @param int scope_id for the record being checked.
 *
 * @return boolean true if the session has the given privilege for the
 * given scope_type_id and scope_id
 */
Datum
veil2_i_have_priv_in_scope(PG_FUNCTION_ARGS)
{
	static void *saved_plan = NULL;
	bool result;
	bool found;
	bool pushed;
	int priv = PG_GETARG_INT32(0);
	int scope_type_id = PG_GETARG_INT32(1);
	int scope_id = PG_GETARG_INT32(2);
	Oid argtypes[] = {INT4OID, INT4OID, INT4OID};
	Datum args[] = {Int32GetDatum(priv),
					Int32GetDatum(scope_type_id),
					Int32GetDatum(scope_id)};
	
	veil2_spi_connect(&pushed,
					  "SPI connect failed in veil2_i_have_priv_in_scope()");

	if (session_ready) {
		found = veil2_bool_from_query(
			"select coalesce("
			" (select privs ? $1"
			"    from veil2_session_privileges v"
			"   where v.scope_type_id = $2"
			"     and v.scope_id = $3), false)",
			3, argtypes, args,
			&saved_plan, &result);

		veil2_spi_finish(pushed,
						 "SPI finish failed in "
						 "veil2_i_have_priv_in_scope()");
		result_counts[found && result]++;
		return found && result;
	}
	if (error_if_no_session()) {
		ereport(ERROR,
				(errcode(ERRCODE_INTERNAL_ERROR),
				 errmsg("Attempt to check privileges before call to  "
						"veil2_reset_session.")));
	}
	else {
		result_counts[false]++;
	}
	return false;
}


/** 
 * <code>veil2.i_have_priv_in_scope_or_global(priv, scope_type_id, scope_id) 
 *     returns bool</code> 
 *
 * Predicate to determine whether the current session user has a given
 * privilege, <code>priv</code>, in a specific scope
 * (<code>scope_type_id</code>, <code>scope_id</code>), or in global scope.
 *
 * @param int privilege_id of privilege to test for
 * @param int scope_type_id of the record being checked.
 * @param int scope_id for the record being checked.
 *
 * @return boolean true if the session has the given privilege for the
 * given scope_type_id and scope_id
 */
Datum
veil2_i_have_priv_in_scope_or_global(PG_FUNCTION_ARGS)
{
	static void *saved_plan = NULL;
	bool result;
	bool found;
	bool pushed;
	int priv = PG_GETARG_INT32(0);
	int scope_type_id = PG_GETARG_INT32(1);
	int scope_id = PG_GETARG_INT32(2);
	Oid argtypes[] = {INT4OID, INT4OID, INT4OID};
	Datum args[] = {Int32GetDatum(priv),
					Int32GetDatum(scope_type_id),
					Int32GetDatum(scope_id)};
	
	veil2_spi_connect(&pushed,
					  "SPI connect failed in veil2_i_have_priv_in_scope_or_global()");

	if (session_ready) {
		found = veil2_bool_from_query(
			"select coalesce("
			" (select union_of(privs) ? $1"
			"    from veil2_session_privileges v"
			"   where (    v.scope_type_id = $2"
			"          and v.scope_id = $3)"
			"      or (    v.scope_type_id = 1"
			"          and v.scope_id = 0)), false)",
			3, argtypes, args,
			&saved_plan, &result);

		veil2_spi_finish(pushed,
						 "SPI finish failed in "
						 "veil2_i_have_priv_in_scope_or_global()");
		result_counts[found && result]++;
		return found && result;
	}
	if (error_if_no_session()) {
		ereport(ERROR,
				(errcode(ERRCODE_INTERNAL_ERROR),
				 errmsg("Attempt to check privileges before call to  "
						"veil2_reset_session.")));
	}
	else {
		result_counts[false]++;
	}
	return false;
}


/** 
 * <code>veil2.i_have_priv_in_superior_scope(priv, scope_type_id, scope_id) 
 *     returns bool</code> 
 *
 * Predicate to determine whether the current session user has a given
 * privilege, <code>priv</code>, in a superior scope to that supplied: 
 * <code>scope_type_id</code>, <code>scope_id</code>.
 *
 * @param int privilege_id of privilege to test for
 * @param int scope_type_id of the record being checked.
 * @param int scope_id for the record being checked.
 *
 * @return boolean true if the session has the given privilege in a
 * scope superior to that given by scope_type_id and scope_id
 */
Datum
veil2_i_have_priv_in_superior_scope(PG_FUNCTION_ARGS)
{
	static void *saved_plan = NULL;
	bool result;
	bool found;
	bool pushed;
	int priv = PG_GETARG_INT32(0);
	int scope_type_id = PG_GETARG_INT32(1);
	int scope_id = PG_GETARG_INT32(2);
	Oid argtypes[] = {INT4OID, INT4OID, INT4OID};
	Datum args[] = {Int32GetDatum(priv),
					Int32GetDatum(scope_type_id),
					Int32GetDatum(scope_id)};
	
	veil2_spi_connect(&pushed,
					  "SPI connect failed in "
					  "veil2_i_have_priv_in_superior_scope()");

	if (session_ready) {
		found = veil2_bool_from_query(
			"select true"
			"  from veil2.all_superior_scopes asp"
			" inner join veil2_session_privileges sp"
			"    on sp.scope_type_id = asp.superior_scope_type_id"
			"   and sp.scope_id = asp.superior_scope_id"
			" where asp.scope_type_id = $2"
			"   and asp.scope_id = $3"
			"   and sp.privs ? $1",
			3, argtypes, args,
			&saved_plan, &result);

		veil2_spi_finish(pushed,
						 "SPI finish failed in "
						 "veil2_i_have_priv_in_superior_scope()");
		result_counts[found && result]++;
		return found && result;
	}
	if (error_if_no_session()) {
		ereport(ERROR,
				(errcode(ERRCODE_INTERNAL_ERROR),
				 errmsg("Attempt to check privileges before call to  "
						"veil2_reset_session.")));
	}
	else {
		result_counts[false]++;
	}
	return false;
}


/** 
 * <code>veil2.i_have_priv_in_scope_or_superior(priv, scope_type_id, scope_id) 
 *     returns bool</code> 
 *
 * Predicate to determine whether the current session user has a given
 * privilege, <code>priv</code>, in the supplied scope or a superior one: 
 * <code>scope_type_id</code>, <code>scope_id</code>.
 *
 * @param int privilege_id of privilege to test for
 * @param int scope_type_id of the record being checked.
 * @param int scope_id for the record being checked.
 *
 * @return boolean true if the session has the given privilege in the
 * scope given by scope_type_id and scope_id or a supeior one.
 */
Datum
veil2_i_have_priv_in_scope_or_superior(PG_FUNCTION_ARGS)
{
	static void *saved_plan1 = NULL;
	static void *saved_plan2 = NULL;
	bool result;
	bool found;
	bool pushed;
	int priv = PG_GETARG_INT32(0);
	int scope_type_id = PG_GETARG_INT32(1);
	int scope_id = PG_GETARG_INT32(2);
	Oid argtypes[] = {INT4OID, INT4OID, INT4OID};
	Datum args[] = {Int32GetDatum(priv),
					Int32GetDatum(scope_type_id),
					Int32GetDatum(scope_id)};
	
	veil2_spi_connect(&pushed,
					  "SPI connect failed in "
					  "veil2_i_have_priv_in_scope_or_superior()");

	if (session_ready) {
		found = veil2_bool_from_query(
			"select coalesce("
			" (select privs ? $1"
			"    from veil2_session_privileges v"
			"   where v.scope_type_id = $2"
			"     and v.scope_id = $3), false)",
			3, argtypes, args,
			&saved_plan1, &result);
		if (!(found && result)) {
			found = veil2_bool_from_query(
				"select true"
				"  from veil2.all_superior_scopes asp"
				" inner join veil2_session_privileges sp"
				"    on sp.scope_type_id = asp.superior_scope_type_id"
				"   and sp.scope_id = asp.superior_scope_id"
				" where asp.scope_type_id = $2"
				"   and asp.scope_id = $3"
				"   and sp.privs ? $1",
				3, argtypes, args,
				&saved_plan2, &result);
		}
		veil2_spi_finish(pushed,
						 "SPI finish failed in "
						 "veil2_i_have_priv_in_scope_or_superior()");
		result_counts[found && result]++;
		return found && result;
	}
	if (error_if_no_session()) {
		ereport(ERROR,
				(errcode(ERRCODE_INTERNAL_ERROR),
				 errmsg("Attempt to check privileges before call to  "
						"veil2_reset_session.")));
	}
	else {
		result_counts[false]++;
	}
	return false;
}


/** 
 * <code>veil2.i_have_priv_in_scope_or_superior_or_global(priv, scope_type_id, scope_id) 
 *     returns bool</code> 
 *
 * Predicate to determine whether the current session user has a given
 * privilege, <code>priv</code>, in global_scope, or the supplied
 * scope, or a superior one: 
 * <code>scope_type_id</code>, <code>scope_id</code>.
 *
 * @param int privilege_id of privilege to test for
 * @param int scope_type_id of the record being checked.
 * @param int scope_id for the record being checked.
 *
 * @return boolean true if the session has the given privilege in the
 * scope given by scope_type_id and scope_id or a supeior one or
 * global scope.
 */
Datum
veil2_i_have_priv_in_scope_or_superior_or_global(PG_FUNCTION_ARGS)
{
	static void *saved_plan1 = NULL;
	static void *saved_plan2 = NULL;
	bool result;
	bool found;
	bool pushed;
	int priv = PG_GETARG_INT32(0);
	int scope_type_id = PG_GETARG_INT32(1);
	int scope_id = PG_GETARG_INT32(2);
	Oid argtypes[] = {INT4OID, INT4OID, INT4OID};
	Datum args[] = {Int32GetDatum(priv),
					Int32GetDatum(scope_type_id),
					Int32GetDatum(scope_id)};
	
	veil2_spi_connect(&pushed,
					  "SPI connect failed in "
					  "veil2_i_have_priv_in_scope_or_superior()");

	if (session_ready) {
		found = veil2_bool_from_query(
			"select coalesce("
			" (select union_of(privs) ? $1"
			"    from veil2_session_privileges v"
			"   where (    v.scope_type_id = $2"
			"          and v.scope_id = $3)"
			"      or (    v.scope_type_id = 1"
			"          and v.scope_id = 0)), false)",
			3, argtypes, args,
			&saved_plan1, &result);
		if (!(found && result)) {
			found = veil2_bool_from_query(
				"select true"
				"  from veil2.all_superior_scopes asp"
				" inner join veil2_session_privileges sp"
				"    on sp.scope_type_id = asp.superior_scope_type_id"
				"   and sp.scope_id = asp.superior_scope_id"
				" where asp.scope_type_id = $2"
				"   and asp.scope_id = $3"
				"   and sp.privs ? $1",
				3, argtypes, args,
				&saved_plan2, &result);
		}
		veil2_spi_finish(pushed,
						 "SPI finish failed in "
						 "veil2_i_have_priv_in_scope_or_superior()");
		result_counts[found && result]++;
		return found && result;
	}
	if (error_if_no_session()) {
		ereport(ERROR,
				(errcode(ERRCODE_INTERNAL_ERROR),
				 errmsg("Attempt to check privileges before call to  "
						"veil2_reset_session.")));
	}
	else {
		result_counts[false]++;
	}
	return false;
}
